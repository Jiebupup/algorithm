[重建二叉树](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github) 

# 方法一 

    public TreeNode reConstructBinaryTree(int[] pre, int[] in) {
        return f(pre, in, 0, pre.length - 1, 0, pre.length - 1);
    }

    private TreeNode f(int[] pre, int[] in, int preLeft, int preRight, int inLeft, int inRight) {
        if (preLeft > preRight) return null;
        TreeNode p = new TreeNode(pre[preLeft]);
        int idx = inLeft;
        while (in[idx] != pre[preLeft]) idx++;
        p.left = f(pre, in, preLeft + 1, idx - inLeft + preLeft, inLeft, idx - 1);
        p.right = f(pre, in, idx - inLeft + preLeft + 1, preRight, idx + 1, inRight);
        return p;
    }
    
# 相关题目

[Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

[Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

[Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)
